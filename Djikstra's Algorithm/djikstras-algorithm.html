<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Djikstra's Algorithm</title>
        <link href="/Ninja/css/test.css" rel="stylesheet" type="text/css">
        <script type="text/javascript">
            //	Djikstra's Algorithm (pseudo-code)
            //	Create an adjacency list which represents the graph
            //	of connected elements (in this case cities)
            //	To do so, create a function - makeRoad - that
            //	takes three arguments: a vertex u, a vertex v and
            //	the weight of their edge
            
            //	Add all the roads in the map to create this adjacency list
            //	For example, you'd call something like this:
            //	makeRoad("City A", "City B", distance);
            //	makeRoad("City A", "City C", distance);
            //	etc ...
            
            //	Now for the algorithm
            //	Djikstra's algorithm uses a graph and a priority queue
            //	First, you create a graph
            //	Second, you take all the vertices in the graph and add
            //	them to the priority queue.  You assign a distance to each
            //	vertex.  Initially, the start vertex is assigned a distance of
            //	zero, and all other vertices are assigned a distance of 'infinity'.
            //	Each vertex is pushed onto the priority queue
            
            //	Then, you initialize the algorithm with the start vertex and
            //	its distance of zero.
            
            //	While the priority queue is not empty
            //	You grab the highest priority vertex off the priority queue
            
            function makeRoad(from, to, distance){
                graph.addEdge(from, to, distance);
            }
            
            function makeRoads(){
                var roads = [];
                roads.push(["Point Kiukiu", "Hanaiapa", 19]);
                roads.push(["Point Kiukiu", "Mt. Feani", 15]);
                roads.push(["Point Kiukiu", "Taaoa", 15]);
                roads.push(["Hanaiapa", "Airport", 6]);
                roads.push(["Mt. Feani", "Airport", 5]);
                roads.push(["Mt. Feani", "Mt. Temetiu", 8]);
                roads.push(["Taaoa", "Mt. Temetiu", 4]);
                roads.push(["Taaoa", "Atuona", 3]);
                roads.push(["Airport", "Atuona", 4]);
                roads.push(["Airport", "Mt. Ootua", 11]);
                roads.push(["Atuona", "Hanakee Pearl Lodge", 1]);
                roads.push(["Hanakee Pearl Lodge", "Cemetery", 6]);
                roads.push(["Cemetery", "Mt. Ootua", 5]);
                roads.push(["Mt. Ootua", "Hanapaoa", 3]);
                roads.push(["Mt. Ootua", "Puamua", 13]);
                roads.push(["Puamua", "Point Teohotepapapa", 14]);
                for (var road in roads) {
                    makeRoad(road[0], road[1], road[2]);
                }
            }
            
            window.onload = function(){
            
                //	Make a graph that is an adjacency list
                var graph = new AdjacencyList();
                
                //	Add all the roads to the graph
                makeRoads();
                
                //	Grab all the vertices in the graph
                var locations = graph.getVertices();
                
                //	Create the priority queue that is implemented with a min-heap
                var priorityQueue = new Heap(graph.size(), function(a, b){
                    if (a.distance > b.distance) {
                        return 1;
                    }
                    if (a.distance < b.distance) {
                        return -1;
                    }
                    return 0;
                });
                
                //	Define the single source
                var source = "Point Kiukiu";
                
                //	Initialize the distance and predecessor lists
                var dist = {};
                var predecessor = {};
                
                //	Initialize the priority queue
                for (var location in locations) {
                    dist[location] = Number.MAX_VALUE;
                    predecessor[location] = -1;
                    priorityQueue.insert({
                        name: location,
                        distance: (location === source ? 0 : Number.MAX_VALUE)
                    });
                }
                
                function findShortestPaths(from,to)
				{
					//	Todo: Terminate the algorithm when u === to
                    while (!priorityQueue.isEmpty()) {
	                    //	Take the point with the lowest distance off of the top of the heap
                        var u = priorityQueue.remove();
                        var neighbors = vertices[u.name];
                        for (var neighbor in neighbors) {
                            var distance = u.distance + neighbor.weight;
							
							//	Todo: Implement the search function to use property names for lookup
							//	Pass in a comparison function to this method
                            var index = priorityQueue.find(neighbor.name);
							
							//	Todo: Implement a getItem method on the priority queue
                            var v = priorityQueue.getItem(index);
							
                            if (v.distance > distance) {
								v.distance = distance ;
								
								//	Todo: Implement the decrease function such that it takes
								//	a property name and value, and sets the appropriate value name
								priorityQueue.decrease(v,distance);
                                dist[v.name] = distance;
                                predecessor[v.name] = u.name;
                            }
                        }
                    }
					
					//	Todo: Add distances
					var f ;
					var t = to ;
					var route = [to] ;
					while (( f = predecessor[t] ) != from ) {
						route.unshift(f);
						t = f ;
					}
					route.unshift(from);
					return route ;
					
                }
            }
        </script>
    </head>
    <body>
        <script src="/Ninja/js/test.js" type="text/javascript">
        </script>
        <script src="/Ninja/js/heap.js" type="text/javascript">
        </script>
        <script src="/Ninja/js/adjacency-list.js" type="text/javascript">
        </script>
        <ul id="results">
        </ul>
    </body>
</html>
