<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Djikstra's Algorithm</title>
        <link href="/Ninja/css/test.css" rel="stylesheet" type="text/css">
        <script type="text/javascript">
            //	Djikstra's Algorithm (pseudo-code)
            //	Create an adjacency list which represents the graph
            //	of connected elements (in this case cities)
            //	To do so, create a function - makeRoad - that
            //	takes three arguments: a vertex u, a vertex v and
            //	the weight of their edge
            
            //	Add all the roads in the map to create this adjacency list
            //	For example, you'd call something like this:
            //	makeRoad("City A", "City B", distance);
            //	makeRoad("City A", "City C", distance);
            //	etc ...
            
            //	Now for the algorithm
            //	Djikstra's algorithm uses a graph and a priority queue
            //	First, you create a graph
            //	Second, you take all the vertices in the graph and add
            //	them to the priority queue.  You assign a distance to each
            //	vertex.  Initially, the start vertex is assigned a distance of
            //	zero, and all other vertices are assigned a distance of 'infinity'.
            //	Each vertex is pushed onto the priority queue
            
            //	Then, you initialize the algorithm with the start vertex and
            //	its distance of zero.
            
            //	While the priority queue is not empty
            //	You grab the highest priority vertex off the priority queue
            
            function makeRoad(from, to, distance){
                graph.addEdge(from, to, distance);
            }
            
            function makeRoads(){
                var roads = [];
                roads.push(["Point Kiukiu", "Hanaiapa", 19]);
                roads.push(["Point Kiukiu", "Mt. Feani", 15]);
                roads.push(["Point Kiukiu", "Taaoa", 15]);
                roads.push(["Hanaiapa", "Airport", 6]);
                roads.push(["Mt. Feani", "Airport", 5]);
                roads.push(["Mt. Feani", "Mt. Temetiu", 8]);
                roads.push(["Taaoa", "Mt. Temetiu", 4]);
                roads.push(["Taaoa", "Atuona", 3]);
                roads.push(["Airport", "Atuona", 4]);
                roads.push(["Airport", "Mt. Ootua", 11]);
                roads.push(["Atuona", "Hanakee Pearl Lodge", 1]);
                roads.push(["Hanakee Pearl Lodge", "Cemetery", 6]);
                roads.push(["Cemetery", "Mt. Ootua", 5]);
                roads.push(["Mt. Ootua", "Hanapaoa", 3]);
                roads.push(["Mt. Ootua", "Puamua", 13]);
                roads.push(["Puamua", "Point Teohotepapapa", 14]);
                for (var i = 0; i < roads.length; i++) {
                    var road = roads[i];
                    makeRoad(road[0], road[1], road[2]);
                }
            }
            
            window.onload = function(){
            
                //	Make a graph that is an adjacency list
                this.graph = new AdjacencyList();
                
                //	Add all the roads to the graph
                makeRoads();
                
                //	Grab all the vertices in the graph
                var locations = graph.getVertices();
                
                //	Create the priority queue that is implemented with a min-heap
                var priorityQueue = new Heap(graph.size(), function(a, b){
                    if (a.distance > b.distance) {
                        return 1;
                    }
                    if (a.distance < b.distance) {
                        return -1;
                    }
                    return 0;
                });
                
                //	Define the single source
                var source = "Point Kiukiu";
                var destination = "Mt. Ootua";
                
                //	Initialize the distance and predecessor lists
                var dist = {};
                var predecessor = {};
                
                //	Initialize the priority queue
                for (var location in locations) {
                    dist[location] = Number.MAX_VALUE;
                    predecessor[location] = -1;
                    priorityQueue.insert({
                        name: location,
                        distance: (location === source ? 0 : Number.MAX_VALUE)
                    });
                }
                
                findShortestPaths(source, destination);
                
                function findShortestPaths(from, to){
                    //	Get the graph's vertices to start
                    var vertices = graph.getVertices();
                    
                    //	Todo: Terminate the algorithm when u === to
                    while (!priorityQueue.isEmpty()) {
                        //	Take the point with the lowest distance off of the top of the heap
                        var u = priorityQueue.remove();
                        var neighbors = vertices[u.name];
                        for (var i = 0; i < neighbors.length; i++) {
                            var neighbor = neighbors[i];
                            var distance = u.distance + neighbor.weight;
                            
                            //	Todo: Implement the search function to use property names for lookup
                            //	Pass in a comparison function to this method
                            var index = priorityQueue.find(neighbor.name, function(a, name){
                                return (a.name === name);
                            });
                            
                            if (index != -1) {
                                //	Todo: Implement a getItem method on the priority queue
                                var v = priorityQueue.getItem(index);
                                
                                if (v.distance > distance) {
                                    v.distance = distance;
                                    
                                    //	Todo: Implement the decrease function such that it takes
                                    //	a property name and value, and sets the appropriate value name
                                    priorityQueue.decrease(v, index);
                                    dist[v.name] = distance;
                                    predecessor[v.name] = u.name;
                                }
                            }
                        }
                    }
                    
                    //	Todo: Add distances
                    var f;
                    var t = to;
                    var route = [to];
                    while ((f = predecessor[t]) != from) {
                        route.unshift(f);
                        t = f;
                    }
                    route.unshift(from);
                    console.log(route);
                    //					return route ;
                }
            }
        </script>
    </head>
    <body>
        <script src="/Ninja/js/test.js" type="text/javascript">
        </script>
        <script src="/Ninja/js/heap.js" type="text/javascript">
        </script>
        <script src="/Ninja/js/adjacency-list.js" type="text/javascript">
        </script>
        <ul id="results">
        </ul>
    </body>
</html>
